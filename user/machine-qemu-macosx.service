[Unit]
Description=qemu vm for macosx

Requires=machine-snapshot@macosx-10.10.service
After=machine-snapshot@macosx-10.10.service

# we mount this data volume
Requires=machine-snapshot@virtdata.service
After=machine-snapshot@virtdata.service

[Service]
Type=simple

Slice=machines.slice

EnvironmentFile=/home/abdo/virt/etc/machines.conf
EnvironmentFile=/home/abdo/virt/etc/machines.d/macosx-10.10.conf

# use pulseaudio on host
Environment=QEMU_AUDIO_DRV=pa

Environment=DISK_DATA_SNAPSHOT=snapshot/virtdata.qcow2

ExecStartPre=/usr/bin/mkdir -p "%t/qemu/${MACHINE}"

# we use directory locks. It is crude but atomic and effective!
ExecStartPre=/usr/bin/mkdir -m 777 "${QEMU}/${DISK_SNAPSHOT}.lock" "${QEMU}/${DISK_DATA_SNAPSHOT}.lock"

# WARNING!: We need this.
# echo 1 > /sys/module/kvm/parameters/ignore_msrs
ExecStartPre=/usr/bin/sudo sh -c 'echo 1 > /sys/module/kvm/parameters/ignore_msrs'

# NOTE: I couldn't make the monitor interface work with a tcp socket.
ExecStart=/usr/bin/qemu-system-x86_64 -name ${MACHINE} \
    -machine type=q35,accel=kvm \
    -boot menu=on \
    -cpu core2duo -smp 2 \
    -m 2048 \
    -vga std \
    -kernel ${QEMU}/${BOOTLOADER_IMAGE} \
    -usb -device usb-kbd -device usb-mouse \
    -monitor unix:%t/qemu/${MACHINE}/control,server,nowait \
    -netdev bridge,id=net_tap,br=brvirt \
    -device e1000-82545em,netdev=net_tap \
    -hda ${QEMU}/${DISK_SNAPSHOT} \
    -hdb ${QEMU}/${DISK_DATA_SNAPSHOT} \
    $QEMU_ARGS

    # -hdb ${QEMU}/${DISK_DATA_SNAPSHOT} \
    # TODO:
    # * fix sluggish mouse
    # *
    # -device usb-mouse \
    # -usbdevice tablet \
    # -device isa-applesmc,osk=${APPLE_OSK} \
    # -smbios type=2
    #     -kernel ${QEMU}/${BOOTLOADER_IMG} -smbios type=2 \
    # -netdev bridge,id=tapvirt,br=brvirt \
    # -device e1000-82545em,netdev=tapvirt,id=mac_vnet0
    # -drive if=ide,snapshot=on,file=${QEMU}/${DISK_CDROM} \
    # -device ide-drive,bus=ide.2,drive=MacHDD \
    # -drive id=MacHDD,if=none,file=${QEMU}/${DISK_SNAPSHOT} \
    # -drive if=ide,snapshot=on,file=${QEMU}/${DISK_CDROM} \
    # -bios /usr/share/ovmf/ovmf_x64.bin \

# NOTE: No ExecStop. Sending SIGTERM to qemu performs a quit, which means clean for qemu,
# not clean for guest. We can't wait until the guest is ready though, so it is ok.

# TODO: machined needs privileges. I think systemd 220 relaxes this!
# TODO: Use RegisterMachineWithNetwork sayssusaio  pass array of ifindices
# TODO: machined assigns quemu's user service to user@1000.service. When terminating everything dies.

# ExecStartPost=/usr/bin/sudo busctl call \
#     org.freedesktop.machine1 /org/freedesktop/machine1 \
#     org.freedesktop.machine1.Manager RegisterMachine \
#     sayssus ${MACHINE} 0 machine vm ${MAINPID} ''

# ExecStopPost=/usr/bin/sudo busctl call \
#     org.freedesktop.machine1 /org/freedesktop/machine1 \
#     org.freedesktop.machine1.Manager TerminateMachine \
#     s ${MACHINE}

ExecStopPost=/usr/bin/rmdir "${QEMU}/${DISK_SNAPSHOT}.lock" "${QEMU}/${DISK_DATA_SNAPSHOT}.lock"

