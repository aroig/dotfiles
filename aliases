#!/bin/zsh
#------------------------------------------------------------------#
# File:     alias.sh   Aliases                                     #
# Version:                                                         #
# Author:   Abd√≥ Roig-Maranges <abdo.roig@gmail.com>               #
#------------------------------------------------------------------#


#------------------------------
# Coloring stuff
#------------------------------
alias ls='ls --human-readable --color=auto -F'
alias ll='ls++ --potsf'
alias lt='tree -C'

alias df='pydf'
alias dul='cdu -dLh -i'
alias du='cdu -dh -i'
alias top='htop'

alias diff='diff -u -d'
alias grep='grep --color=auto'


# alias ping='$HOME/Software/conf/color-wrappers/ping'
# alias unisonb='$HOME/Software/conf/color-wrappers/unison -batch'

set_tty_colors() {
    # Extract colors from .Xresources
    _SEDCMD='s/urxvt\.color\([0-9]\{1,\}\).*#\([0-9a-fA-F]\{6\}\).*/\1 \2/p'
    for i in $(sed -n "$_SEDCMD" $HOME/.Xresources | awk '$1 < 16 {printf "\\e]P%X%s", $1, $2}'); do
        echo -en "$i"
    done
    echo -e "\\e]P0000000"
}


#------------------------------
# Wine aliases
#------------------------------
alias kindle='wine "$HOME/.wine/drive_c/Program Files (x86)/Amazon/Kindle/Kindle.exe"'
alias digitaleditions='wine "$HOME/.wine/drive_c/Program Files (x86)/Adobe/Adobe Digital Editions/digitaleditions.exe"'


#------------------------------
# Utility aliases
#------------------------------

alias trash='gvfs-trash'
alias vp='vimpager'
alias vc='vimcat'
alias rsy='rsync -avz --progress --delete'
alias ediff='emacs -diff'
alias mr='mr --stats'

alias mailq='msmtp-queue'

alias ahi='ictl hi.target'
alias abye='ictl bye.target'
alias pac='sudo pacman'
alias cow='cower'

alias feh='feh --magick-timeout 2 --scale-down --fontpath /usr/share/fonts/TTF/ --font DejaVuSans/10'
alias ipy='ipython'
alias ipy2='ipython2'

alias wee='weechat-curses'

gateway() { host `ip route list 0/0 | awk '{print $3}'` | awk '{print $5}'; }

alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
alias ......="cd ../../../../.."


#------------------------------
# Auxiliar functions
#------------------------------

xrandr_screens() { xrandr -q | grep " connected" | sed 's/^\([A-Za-z0-9\-]*\).*/\1/'; }

# remove trailing newline.
trimtrail() {
    cat "$1" | awk '{a = $0; while (getline > 0) {print a; a = $0}} END {printf("%s", a)}' -
}


#------------------------------
# tmux functions
#------------------------------

# create a new client session attached to an existing one, and then create a new window
tmux_client() {
    session="$1"
    [ ! "$session" ] && session="default"
    shift

    tmux -S "$XDG_RUNTIME_DIR/tmux/$session" \
        new-session -t $session -s $session-$$\; \
        new-window\; \
        set destroy-unattached on\; "$@"
}


# create a new tmux session attached to an existing one master session
# launching the master if necessary
tmux_session() {
    session="default"

    ( tmux_client "$session" && \
      exit 0 
    ) || \
    ( systemctl --user start tmux.service && \
      tmux_client "$session" && \
      exit 0 
    )
}

# detach from tmux
detach() {
    if [[ "$TMUX" != "" ]]; then
        tmux detach-client
    fi
}

# if inside tmux close window and detach
exit() {
    if [[ -z "$TMUX" ]]; then
        builtin exit
    else
        tmux unlink-window -k\; detach-client
    fi
}


#------------------------------
# gnupg functions
#------------------------------

# sets the default keyring to use
#  default: the one at ~/.gnupg
#  master:  the one at ~/priv/gnupg
#
# TODO: what about the gpg-agent sockets?
gpg_keyring() {
    case "$1" in
       master)
            export GPGHOME="$AB2_PRIV_DIR/gnupg"
            ;;
        
        default)
            export GPGHOME="$HOME/.gnupg"
            ;;
    esac
}


# forwards requests to the agent from a remote
gpg_agent_forward() {
    remote="$1"
    socket_cmd="socat UNIX-LISTEN:/home/abdo/.gnupg/S.gpg-agent.forward,unlink-close,unlink-early STDIO"
    gpg_socket="${$GPG_AGENT_INFO%::1}"
    socat  SYSTEM:"ssh -S none $remote \"$socket_cmd\"" UNIX-CONNECT:"$gpg_socket"
}


# sets the mode for the gpg-agent
#  tty:     we are on a local tty
#  graphic: we are on a grahic environment
#  ssh:     we forward agent calls to the client
gpg_agent_mode() {

    case "$1" in
        tty)
            ssh_sock="$XDG_RUNTIME_DIR/gpg-agent/S.gpg-agent.ssh"
            gpg_sock="$XDG_RUNTIME_DIR/gpg-agent/S.gpg-agent"       
            ;;

        graphic)
            ssh_sock="$XDG_RUNTIME_DIR/gpg-agent/S.gpg-agent.ssh"
            gpg_sock="$XDG_RUNTIME_DIR/gpg-agent/S.gpg-agent"           
            ;;

        ssh)
            ssh_sock="$XDG_RUNTIME_DIR/gpg-agent/S.gpg-agent.ssh.forward"
            gpg_sock="$XDG_RUNTIME_DIR/gpg-agent/S.gpg-agent.forward"
            ;;
    esac

    export SSH_AUTH_SOCK="$ssh_sock"
    export GPG_AGENT_INFO="$gpg_sock::1"

    case "$1" in
        tty|graphic)
            gpg_agent_update
            ;;
    esac
}


# Update tty for the gpg-agent. gpg itself can be aware of the tty,
# maybe via GPG_TTY environment var, but there is no way that programs using
# gpg-agent as a ssh-agent can tell it about the tty. So we are stuck with this.
gpg_agent_update() {
    export GPG_TTY=$(tty)
    gpg-connect-agent updatestartuptty /bye
}


#------------------------------
# Systemd aliases
#------------------------------


alias jctl="sudo journalctl --since=yesterday"
alias ectl="sudo journalctl --since=yesterday --priority=0..3"

alias nctl="sudo netctl"
alias mctl="sudo machinectl"
alias lctl="sudo loginctl"
alias sctl="sudo systemctl --system"
alias uctl="systemctl --user"

alias actl="systemd-analyze"
alias nspawn="sudo systemd-nspawn"
alias sdrun="systemd-run --user"

alias cgls="systemd-cgls --no-pager"
alias cgtop="systemd-cgtop"

actl_svg() {
    cmd="$1"; shift
    if [ "$cmd" = "dot" ]; then systemd-analyze dot "$@" | dot -Tsvg
    else                        systemd-analyze "$cmd" "$@"
    fi
}

alias lock='systemctl --user lock.target'

# firewall
fws() { sudo iptables -L firewall; echo ""; sudo iptables -n -L sshguard; }
fwban() { sudo iptables -A sshguard -s "$1" -j DROP; }


#------------------------------
# development
#------------------------------

case $(hostname -s) in
    grothendieck)
        threads=10
        ;;
    galois|hodge)
        threads=3
        ;;
    *)
        threads=1
        ;;
esac

mk() { MAKE="make -j$threads" make "$@" 2>&1 | colormake; return ${PIPESTATUS[0]}; }

alias gan="git annex"


#------------------------------
# sudo
#------------------------------

# If the argument has an alias, expand it, if it has a function, 
# run it on a root shell and if no arguments given, go to a root shell.
sudo () {
    sudo=/usr/bin/sudo
    
    if [[ -n "$1" ]]; then
        if [[ -n "${=aliases[$1]}" ]]; then
            $sudo ${=aliases[$1]} $argv[2,-1]
        elif [[ -n "${=functions[$1]}" ]]; then
            # TODO: need to escape $argv
            $sudo zsh -ic "$argv"
        else
            $sudo $argv
        fi
    else
        $sudo zsh
    fi
}

# alias sudo='sudo '        # Enables expanding aliases for next command. not functions though :(


#------------------------------
# Program shortcuts
#------------------------------

vi()  { eval "$EDITOR \"\$@\""; }
op()  { xdg-open "$@" &> /dev/null &!; }


# The following commands are aware of the type of terminal they are on. For
# example ed launches GTK emacs on any terminal except tty's or remote logins

ee() {
    case "$TERM" in
        screen*|linux*) eval "$EMACSCLIENT -t \"\$@\" > /dev/null" ;;
        *)              eval "$EMACSCLIENT -c \"\$@\" > /dev/null &!" ;;
    esac
}

kle() {
    case "$TERM" in
        screen*|linux) eval "$EMACSCLIENT -eval \"(client-save-kill-emacs)\" &> /dev/null"  ;;
        *)             eval "$EMACSCLIENT --display=:0 --eval \"(client-save-kill-emacs)\" &> /dev/null \"\$@\" &!" ;;
    esac
}

tx() {
    if [ "$TMUX" ]; then   tmux new-window
    else                   tmux_session default
    fi
}

tm()  {
    case "$TERM" in
        screen*|linux) tx ;;
        *)             eval "$TERMCMD -d \"\$PWD\" \"\$@\" &!" ;;
    esac
}

rg()  {
    case "$TERM" in
        screen*|linux) eval "ranger \"\$@\"" ;;
        *)             eval "$TERMCMD -d \"\$PWD\" -e ranger \"\$@\" &!" ;;
    esac
}

fm()  {
    case "$TERM" in
        screen*|linux) eval "ranger \"\$@\"" ;;
        *)             eval "$FILEMANAGER \"\$@\" &> /dev/null &!" ;;
    esac
}



# These commands open awesome dropdown clients
rgd() { echo "ddclient.ranger:newtab('$PWD')"   | awesome-client; }
tmd() { echo "ddclient.terminal:newtab('$PWD')" | awesome-client; }


#------------------------------
# Starting and killing X
#------------------------------

# stx() { startx awesome -- vt$(fgconsole 2>/dev/null); }
stx() {
    if [ ! "$1" ]; then  wm=awesome
    else                 wm="$1"
    fi

    xvt=vt$(fgconsole)
    if [ "$?" = '0' ]; then
        systemctl --user set-environment XORG_VT=$xvt
        systemctl --user start wm@$wm.target;
    fi

    # wait until X server finishes and reset the tty
    wait $(pgrep xorg)
    sleep 1
    reset
    set_tty_colors
}

klx() { 
    systemctl --user start console.target;
}


#------------------------------
# Rebooting and halting
#------------------------------

alias reboot="sudo systemctl reboot"
alias poweroff="sudo systemctl poweroff"
alias suspend="sudo systemctl suspend"

